import { Project, VariableDeclarationKind } from "ts-morph";
import { KwilAction, Value } from "../parser";
import fs from "node:fs";

function toCamelCase(snake: string): string {
  return snake.replace(/_([a-z])/g, (_, c) => c.toUpperCase());
}

export function generateKotlin(methods: KwilAction[]) {
  const file = fs.createWriteStream("Actions.kt", { flags: "w" });

  file.write("// This file is generated by the generator. Do not edit it manually.\n");
  file.write("// check github.com/idos-networks/idos-schema\n\n");

  file.write("package org.idos.kwil.actions\n");
  file.write("import kotlinx.serialization.SerialName\n");
  file.write("import kotlinx.serialization.Serializable\n");
  file.write("import org.idos.kwil.utils.SchemaField\n");
  file.write("import org.idos.kwil.utils.DataType\n");
  file.write("import org.idos.kwil.KwilActionClient\n\n")

  const kotlinTypeMapping = {
    TEXT: "String",
    UUID: "String",
    INT: "Int",
    BOOLEAN: "Boolean",
    BOOL: "Boolean",
    INT8: "Int",
  }

  const kotlinSchemMapping = {
    TEXT: "DataType.Text",
    UUID: "DataType.Uuid",
    INT: "DataType.Int",
    BOOLEAN: "DataType.Boolean",
    BOOL: "DataType.Boolean",
    INT8: "DataType.Int",
  }

  // Generate action schema
  file.write(`
object ActionSchema {
    val schemas =
        mapOf(
`);

  methods.forEach(method => {
    file.write(`"${method.name}" to listOf(\n`);
    method.args.forEach(arg => {
      file.write(`SchemaField("${arg.name}", ${kotlinSchemMapping[arg.type]}),\n`);
    });
    file.write(`),\n`);
  });

  file.write(")\n");

  file.write("fun getSchema(actionName: String): List<SchemaField>? = schemas[actionName]\n");
  file.write("}\n\n");

  // Generate methods
  methods.forEach(method => {
    const name = toCamelCase(method.name);
    const prefix = name[0].toUpperCase() + name.slice(1);

    // Generate methods
    method.comments.forEach(comment => {
      file.write(`// ${comment}\n`);
    });

    // Generate serializable response
    if (method.returns.length > 0) {
      file.write(`
@Serializable
data class ${prefix}Response(
${method.returns.map(ret => {
        const optional = method.generatorComments.returnOptional?.includes(ret.name) ? "?" : "";
        const field = `val ${toCamelCase(ret.name)}: ${kotlinTypeMapping[ret.type]}${optional}`;

        if (ret.name != toCamelCase(ret.name)) {
          return `  @SerialName("${ret.name}")\n  ${field}`;
        } else {
          return `  ${field}`;
        }
      }).join(",\n")}
)
`)
    }

    let returnItem = "";
    let returnItemType = "";
    if (method.returns.length > 0) {
      returnItem = returnItemType = `${prefix}Response`;
      if (method.returnsArray) {
        returnItem = "List<" + returnItem + ">";
      }
      returnItem = ": " + returnItem;
    }

    let methodArgs: string[] = ["client: KwilActionClient"];
    let callArgs: string[] = [];
    method.args.forEach(arg => {
      const optional = method.generatorComments.paramOptional?.includes(arg.name) ? "?" : "";
      methodArgs.push(`${toCamelCase(arg.name)}: ${kotlinTypeMapping[arg.type]}${optional}`);
      callArgs.push(`"${arg.name}" to ${toCamelCase(arg.name)}`);
    });

    if (method.view) {
      file.write(`
suspend fun ${name}(${methodArgs.join(",\n")})${returnItem} {
  return client.callAction<${returnItemType}>("${method.name}", mapOf(
    ${callArgs.join(",\n    ")}
  ))${!method.returnsArray ? ".first()" : ""}
}`);
    } else {
      file.write(`
suspend fun ${name}(${methodArgs.join(",\n")}): String? {
    return client.executeAction("${method.name}", mapOf(
      ${callArgs.join(",\n    ")}
    ), "${method.generatorComments.description}", true);
}`);
    }

    file.write("\n");
  });

  file.close();
}
