import { KwilAction } from "../parser";
import fs from "node:fs";
import path from "node:path";
import { mkdir } from "node:fs/promises";

// Utility functions
function toCamelCase(snake: string): string {
  return snake.replace(/_([a-z])/g, (_, c) => c.toUpperCase());
}

function toPascalCase(snake: string): string {
  const camel = toCamelCase(snake);
  return camel[0].toUpperCase() + camel.slice(1);
}

// Type mappings
const kotlinTypeMapping: Record<string, string> = {
  TEXT: "String",
  UUID: "UuidString",
  INT: "Int",
  BOOLEAN: "Boolean",
  BOOL: "Boolean",
  INT8: "Int",
};

const kotlinSchemaMapping: Record<string, string> = {
  TEXT: "DataType.Text",
  UUID: "DataType.Uuid",
  INT: "DataType.Int",
  BOOLEAN: "DataType.Boolean",
  BOOL: "DataType.Boolean",
  INT8: "DataType.Int",
};

// File writers
async function ensureDirectoryExists(dir: string) {
  await mkdir(dir, { recursive: true });
}

interface MethodInfo {
  args: Array<{ name: string; type: string }>;
  returns?: Array<{ name: string; type: string }>;
  view?: boolean;
  generatorComments?: {
    paramOptional?: string[];
    description?: string;
  };
}

function writeFileHeader(file: fs.WriteStream, packageName: string, method?: MethodInfo, imports: string[] = []) {
  file.write(`// This file is generated by the generator. Do not edit it manually.\n`);
  file.write(`// check github.com/idos-networks/idos-schema\n\n`);
  file.write(`package ${packageName}\n\n`);

  // Start with no imports, we'll add them based on actual usage
  const usedImports = new Set<string>();

  // Always add kotlinx.serialization.Serializable for view actions
  if (packageName.endsWith('.view')) {
    usedImports.add('import kotlinx.serialization.Serializable');
    usedImports.add('import kotlinx.serialization.SerialName');
  }

  // Track which imports are actually used
  const usedTypes = new Set<string>();

  // Check for UuidString usage in parameters and return types
  const allArgs = [...(method?.args || []), ...(method?.returns || [])];
  const hasUuidString = allArgs.some(arg => arg.type === 'UUID');
  if (hasUuidString) {
    usedTypes.add('UuidString');
    usedImports.add('import org.idos.kwil.rpc.UuidString');
  }

  // Check for DataType usage in positional types
  const hasPositionalTypes = method?.args?.length > 0;
  if (hasPositionalTypes) {
    usedTypes.add('PositionalParams');
    usedTypes.add('PositionalTypes');
    usedTypes.add('DataType');
    usedImports.add('import org.idos.kwil.transaction.PositionalParams');
    usedImports.add('import org.idos.kwil.transaction.PositionalTypes');
    usedImports.add('import org.idos.kwil.serialization.DataType');
  }

  // Add action type import
  if (packageName.endsWith('.view')) {
    const hasParams = method && method.args && method.args.length > 0;
    if (hasParams) {
      usedImports.add('import org.idos.kwil.actions.ViewAction');
    } else {
      usedImports.add('import org.idos.kwil.actions.NoParamsAction');
    }
  } else if (packageName.endsWith('.execute')) {
    usedImports.add('import org.idos.kwil.actions.ExecuteAction');
  }

  const allImports = Array.from(usedImports).sort();
  file.write(allImports.join('\n') + '\n\n');
}

// Response class generator
function generateResponseClass(file: fs.WriteStream, methodName: string, returns: any[], returnsArray: boolean, actionType: 'view' | 'execute', generatorComments?: any) {
  const className = `${toPascalCase(methodName)}Response`;

  if (returns.length === 0) return null;

  // Get list of optional return fields from generator comments
  const optionalReturnFields = generatorComments?.returnOptional || [];

  file.write(`@Serializable\ndata class ${className}(\n`);

  const fields = returns.map(ret => {
    const fieldType = kotlinTypeMapping[ret.type] || 'String';
    const fieldName = toCamelCase(ret.name);
    const isOptional = optionalReturnFields.includes(ret.name);
    return `    @SerialName("${ret.name}") val ${fieldName}: ${fieldType}${isOptional ? '?' : ''}`;
  }).join(',\n');

  file.write(`${fields},\n`);
  file.write(')\n\n');

  return className;
}

// Parameter class generator
function generateParameterClass(file: fs.WriteStream, methodName: string, args: any[], optionalParams: string[] = [], actionType: 'view' | 'execute') {
  if (args.length === 0) return null;

  const className = `${toPascalCase(methodName)}Params`;

  file.write(`data class ${className}(\n`);

  const fields = args.map(arg => {
    const fieldType = kotlinTypeMapping[arg.type] || 'String';
    const isOptional = optionalParams.includes(arg.name);
    const fieldName = toCamelCase(arg.name);
    return `    val ${fieldName}: ${fieldType}${isOptional ? '?' : ''}`;
  }).join(',\n');

  file.write(`${fields},\n`);
  file.write(')\n\n');

  return className;
}

// View action generator
async function generateViewAction(method: any, outputDir: string) {
  const methodName = toCamelCase(method.name);
  const className = toPascalCase(method.name);
  const outputFile = path.join(outputDir, 'view', `${className}.kt`);

  await ensureDirectoryExists(path.dirname(outputFile));
  const file = fs.createWriteStream(outputFile);

  // Write file header
  writeFileHeader(file, 'org.idos.kwil.actions.generated.view', method);

  // Generate response class if needed
  const responseType = generateResponseClass(
    file,
    method.name,
    method.returns,
    method.returnsArray,
    method.view ? 'view' : 'execute',
    method.generatorComments
  );

  // Generate parameter class if there are parameters
  const hasParams = method.args.length > 0;
  let paramType = null;

  if (hasParams) {
    paramType = generateParameterClass(
      file,
      method.name,
      method.args,
      method.generatorComments?.paramOptional || [],
      method.view ? 'view' : 'execute'
    );
  }

  // Add KDoc comments
  if (method.comments && method.comments.length > 0) {
    file.write('/**\n');
    method.comments.forEach((comment: string) => {
      file.write(` * ${comment}\n`);
    });
    file.write(' */\n');
  }

  // Generate action class as object
  if (hasParams) {
    file.write(`object ${className} : ViewAction<${paramType}, ${responseType || 'Unit'}> {\n`);
    file.write(`    override val name: String = "${method.name}"\n`);
    file.write(`    override val namespace: String = "main"\n\n`);

    // Generate positional types
    file.write(`    override val positionalTypes: PositionalTypes =\n`);
    file.write(`        listOf(\n`);
    method.args.forEach((arg: { name: string; type: string }) => {
      const type = kotlinSchemaMapping[arg.type] || 'DataType.Text';
      file.write(`            ${type},\n`);
    });
    file.write(`        )\n\n`);

    // Generate toPositionalParams
    file.write(`    override fun toPositionalParams(input: ${paramType}): PositionalParams =\n`);
    file.write(`        listOf(\n`);
    method.args.forEach((arg: { name: string; type: string }) => {
      const fieldName = toCamelCase(arg.name);
      const isUuid = arg.type === 'UUID';
      const isOptional = method.generatorComments?.paramOptional?.includes(arg.name) || false;
      const accessor = isUuid ? (isOptional ? '?.value' : '.value') : '';
      file.write(`            input.${fieldName}${accessor},\n`);
    });
    file.write(`        )\n`);

    file.write(`}\n`);
  } else {
    // No parameters - use NoParamsAction
    file.write(`object ${className} : NoParamsAction<${responseType}>() {\n`);
    file.write(`    override val namespace: String = "main"\n`);
    file.write(`    override val name: String = "${method.name}"\n`);
    file.write(`}\n`);
  }

  file.close();
  return className;
}

// Execute action generator
async function generateExecuteAction(method: any, outputDir: string) {
  const methodName = toCamelCase(method.name);
  const className = toPascalCase(method.name);
  const outputFile = path.join(outputDir, 'execute', `${className}.kt`);

  await ensureDirectoryExists(path.dirname(outputFile));
  const file = fs.createWriteStream(outputFile);

  // Write file header
  writeFileHeader(file, 'org.idos.kwil.actions.generated.execute', method);

  // Generate parameter class
  const paramType = generateParameterClass(
    file,
    method.name,
    method.args,
    method.generatorComments?.paramOptional || [],
    'execute'
  );

  // Generate action class as object
  file.write(`object ${className} : ExecuteAction<${paramType || 'Unit'}> {\n`);
  file.write(`    override val name: String = "${method.name}"\n`);
  file.write(`    override val namespace: String = "main"\n`);

  // Handle description with line length check
  const description = method.generatorComments?.description || '';
  const descriptionLine = `    override val description: String = "${description}"`;

  if (descriptionLine.length > 140) {
    file.write('    override val description: String =\n');
    file.write(`        "${description}"\n\n`);
  } else {
    file.write(`${descriptionLine}\n\n`);
  }

  // Generate positional types
  file.write(`    override val positionalTypes: PositionalTypes =\n`);
  file.write(`        listOf(\n`);
  method.args.forEach((arg: { type: string; name: string }) => {
    const type = kotlinSchemaMapping[arg.type] || 'DataType.Text';
    file.write(`            ${type},\n`);
  });
  file.write(`        )\n\n`);

  // Generate toPositionalParams
  file.write(`    override fun toPositionalParams(input: ${paramType || 'Unit'}): PositionalParams =\n`);
  file.write(`        listOf(\n`);
  if (paramType) {
    method.args.forEach((arg: { name: string; type: string }) => {
      const fieldName = toCamelCase(arg.name);
      const isUuid = arg.type === 'UUID';
      const isOptional = method.generatorComments?.paramOptional?.includes(arg.name) || false;
      const accessor = isUuid ? (isOptional ? '?.value' : '.value') : '';
      file.write(`            input.${fieldName}${accessor},\n`);
    });
  }
  file.write(`        )\n`);

  file.write(`}\n`);

  file.close();
  return className;
}

// Main generator function
export async function generateKotlin(methods: KwilAction[]) {
  const outputDir = path.join(process.cwd(), 'generated');
  await ensureDirectoryExists(outputDir);

  const viewDir = path.join(outputDir, 'view');
  const executeDir = path.join(outputDir, 'execute');

  await ensureDirectoryExists(viewDir);
  await ensureDirectoryExists(executeDir);

  const viewActions: string[] = [];
  const executeActions: string[] = [];

  // Process each method
  for (const method of methods) {
    if (method.view) {
      const className = await generateViewAction(method, outputDir);
      viewActions.push(className);
    } else {
      const className = await generateExecuteAction(method, outputDir);
      executeActions.push(className);
    }
  }

  console.log(`Generated ${viewActions.length} view actions and ${executeActions.length} execute actions`);
}
