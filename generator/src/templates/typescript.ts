import { Project, VariableDeclarationKind, Writers } from "ts-morph";
import { KwilAction, Value } from "../parser";

function toCamelCase(snake: string): string {
  return snake.replace(/_([a-z])/g, (_, c) => c.toUpperCase());
}


export function generateTypescript(methods: KwilAction[]) {
  const project = new Project();
  const sourceFile = project.createSourceFile("generated_actions.ts", "", { overwrite: true });

  sourceFile.insertText(0, "// This file is generated by the generator. Do not edit it manually.");

  sourceFile.addImportDeclarations([
    {
      moduleSpecifier: "zod",
      namedImports: ["z"],
    },
    {
      moduleSpecifier: "@kwilteam/kwil-js",
      namedImports: ["Utils"],
    },
    {
      moduleSpecifier: "../kwil-infra",
      namedImports: ["KwilActionClient"],
    },
  ]);

  sourceFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    isExported: true,
    declarations: [
      {
        name: "DataType",
        type: "typeof Utils.DataType",
        initializer: `Utils.DataType`,
      }
    ]
  })

  sourceFile.addTypeAlias({
    isExported: true,
    name: "ActionSchemaElement",
    type: `{
      name: string;
      type: typeof DataType.Uuid | typeof DataType.Text | typeof DataType.Int;
    }`,
  })

  const schemaDbMapping = {
    TEXT: "DataType.Text",
    UUID: "DataType.Uuid",
    INT: "DataType.Int",
    BOOLEAN: "DataType.Boolean",
    BOOL: "DataType.Boolean",
    INT8: "DataType.Int",
  }

  // Generate action schema
  sourceFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    isExported: true,
    declarations: [
      {
        name: "actionSchema",
        type: "Record<string, ActionSchemaElement[]>",
        initializer: writer => {
          writer.block(() => {
            methods.forEach(method => {
              if (method.args.length > 0) {
                writer.writeLine(`${method.name}: [`);
                  method.args.forEach(arg => {
                    writer.inlineBlock(() => {
                      writer.writeLine(`name: "${arg.name}", type: ${schemaDbMapping[arg.type]},`);
                    });
                    writer.write(",");
                  });
                writer.writeLine("],");
              }
            })
          });
        }
      },
    ],
  });

  const zodDbMapping = {
    TEXT: "string",
    UUID: "string",
    INT: "number",
    BOOLEAN: "boolean",
    BOOL: "boolean",
    INT8: "number",
  }

  function generateZodType(name: string, args: Value[], optionals: string[] = [], isArray = false) {
    if (args.length === 0) return;

    sourceFile.addVariableStatement({
      declarationKind: VariableDeclarationKind.Const,
      isExported: true,
      declarations: [
        {
          name: `${name}Schema`,
          initializer: writer => {
            writer.write(`z.object(`);
            writer.inlineBlock(() => {
              args.forEach(arg => {
                writer.write(`${arg.name}: z.${zodDbMapping[arg.type]}()`);
                writer.conditionalWrite(optionals.includes(arg.name), () => `.optional()`);
                writer.write(",");
                writer.newLine();
              });
            });
            writer.write(")");
            writer.conditionalWrite(!!isArray, () => ".array()");
            writer.writeLine("");
          },
        },
      ],
    });

    sourceFile.addTypeAlias({
      isExported: true,
      name,
      type: `z.infer<typeof ${name}Schema>`,
    });
  }

  methods.forEach(method => {
    const name = toCamelCase(method.name);
    const prefix = name[0].toUpperCase() + name.slice(1);

    const output = method.returns.length > 0 ? `${prefix}Output` : "void";

    // Zod schema for inputs
    if (method.args.length > 0) {
      generateZodType(`${prefix}Input`, method.args, method.generatorComments.param_optional);
    }

    if (method.returns.length > 0) {
      generateZodType(`${prefix}Output`, method.returns, [], method.returnsArray);
    }

    const functionDeclaration = sourceFile.addFunction({
      name,
      isExported: true,
      isAsync: true,
      returnType: `Promise<${output}>`,
      parameters: [
        {
          name: "kwilClient",
          type: "KwilActionClient",
        },
        ...(method.args.length > 0 ? [{
          name: "params",
          type: `${prefix}Input`,
        }] : []),
      ],
    });

    if (method.comments.length > 0) {
      functionDeclaration.addJsDoc(method.comments.join("\n"));
    }

    functionDeclaration.setBodyText(writer => {
      let returnStatement = method.returns.length > 0 ? "return" : "";
      let methodCall = method.returns.length > 0 ? "call" : "execute";

      if (method.args.length > 0) {
        writer.writeLine(`const inputs = ${prefix}InputSchema.parse(params);`);
        writer.writeLine(`${returnStatement} await kwilClient.${methodCall}(`)
        writer.block(() => {
          writer.writeLine(`name: "${method.name}",`);
          writer.writeLine(`inputs,`);
          writer.conditionalWrite(!!method.generatorComments.description, () => `description: "${method.generatorComments.description}",`);
        });
        writer.conditionalWriteLine(method.generatorComments.not_authorized, () => `, undefined, // Signer is not required here`);
        writer.writeLine(");");
      } else {
        writer.writeLine(`${returnStatement} await kwilClient.${methodCall}({ name: "${method.name}", inputs: {} });`);
      }
    })
  });

  sourceFile.formatText({
    placeOpenBraceOnNewLineForControlBlocks: true,
  })
  sourceFile.saveSync();
}