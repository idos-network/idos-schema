import { Project, VariableDeclarationKind } from "ts-morph";
import { KwilAction, Value } from "../parser";

function toCamelCase(snake: string): string {
  return snake.replace(/_([a-z])/g, (_, c) => c.toUpperCase());
}

export function generateTypescript(methods: KwilAction[]) {
  const project = new Project();
  const sourceFile = project.createSourceFile("generated_actions.ts", "", { overwrite: true });

  sourceFile.insertText(0, "// This file is generated by the generator. Do not edit it manually.");

  sourceFile.addImportDeclarations([
    {
      moduleSpecifier: "@idos-network/kwil-js",
      namedImports: ["Utils"],
    },
    {
      moduleSpecifier: "zod",
      defaultImport: "* as z",
    },
    {
      moduleSpecifier: "../",
      isTypeOnly: true,
      namedImports: ["KwilActionClient"],
    },
  ]);

  sourceFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    isExported: true,
    declarations: [
      {
        name: "DataType",
        type: "typeof Utils.DataType",
        initializer: `Utils.DataType`,
      }
    ]
  })

  sourceFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    isExported: true,
    declarations: [
      {
        name: "WALLET_TYPES",
        initializer: `['EVM', 'NEAR', 'XRPL', 'Stellar', 'FaceSign'] as const`,
      }
    ]
  })

  sourceFile.addTypeAlias({
    isExported: true,
    name: "WalletType",
    type: "(typeof WALLET_TYPES)[number]",
  });

  sourceFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    isExported: true,
    declarations: [
      {
        name: "walletTypeSchema",
        type: "z.ZodType<WalletType>",
        initializer: `z.enum(WALLET_TYPES)`,
      }
    ]
  });

  sourceFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    isExported: true,
    declarations: [
      {
        name: "ENCRYPTION_PASSWORD_STORES",
        initializer: `['user', 'mpc'] as const`,
      }
    ]
  })

  sourceFile.addTypeAlias({
    isExported: true,
    name: "EncryptionPasswordStore",
    type: "(typeof ENCRYPTION_PASSWORD_STORES)[number]",
  });

  sourceFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    isExported: true,
    declarations: [
      {
        name: "encryptionPasswordStoreSchema",
        type: "z.ZodType<EncryptionPasswordStore>",
        initializer: `z.enum(ENCRYPTION_PASSWORD_STORES)`,
      }
    ]
  });

  sourceFile.addTypeAlias({
    isExported: true,
    name: "ActionSchemaElement",
    type: `{
      name: string;
      type: typeof DataType.Uuid | typeof DataType.Text | typeof DataType.Int | typeof DataType.Boolean;
    }`,
  })

  const schemaDbMapping = {
    TEXT: "DataType.Text",
    UUID: "DataType.Uuid",
    INT: "DataType.Int",
    BOOLEAN: "DataType.Boolean",
    BOOL: "DataType.Boolean",
    INT8: "DataType.Int",
    NUMERIC: "DataType.Int",
  }

  // Generate action schema
  sourceFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    isExported: true,
    declarations: [
      {
        name: "actionSchema",
        type: "Record<string, ActionSchemaElement[]>",
        initializer: writer => {
          writer.inlineBlock(() => {
            methods.forEach(method => {
              writer.writeLine(`${method.name}: [`);
              method.args.forEach(arg => {
                writer.inlineBlock(() => {
                  writer.writeLine(`name: "${arg.name}",`);
                  writer.writeLine(`type: ${schemaDbMapping[arg.type]},`);
                });
                writer.write(",");
                writer.newLineIfLastNot();
              });
              writer.writeLine("],");
            })
          });
        }
      },
    ],
  });

  const zodDbMapping = {
    TEXT: "string",
    UUID: "uuid",
    INT: "number",
    BOOLEAN: "boolean",
    BOOL: "boolean",
    INT8: "number",
    NUMERIC: "number",
  }

  const customZodDbMapping: Record<string, string> = {
    wallet_type: "walletTypeSchema",
    encryption_password_store: "encryptionPasswordStoreSchema",
  }

  const zodTypeMapping = {
    TEXT: "ZodString",
    UUID: "ZodUUID",
    INT: "ZodNumber",
    BOOLEAN: "ZodBoolean",
    BOOL: "ZodBoolean",
    INT8: "ZodNumber",
    NUMERIC: "ZodNumber",
  }

  const customZodTypeMapping: Record<string, string> = {
    wallet_type: "z.ZodType<WalletType>",
    encryption_password_store: "z.ZodType<EncryptionPasswordStore>",
  }

  function generateZodType(name: string, args: Value[], {
    optionals = [],
  }: {
    optionals?: string[],
  } = {}): string | undefined {
    if (args.length === 0) return;

    sourceFile.addVariableStatement({
      declarationKind: VariableDeclarationKind.Const,
      isExported: true,
      declarations: [
        {
          name: `${name}Schema`,
          type: writer => {
            writer.write(`z.ZodObject < `);
            writer.inlineBlock(() => {
              args.forEach(arg => {
                writer.write(`${arg.name}: `);
                if (optionals.includes(arg.name)) {
                  writer.write("z.ZodNullable<");
                }

                if (customZodTypeMapping[arg.name]) {
                  writer.write(`${customZodTypeMapping[arg.name]} `);
                } else {
                  writer.write(`z.${zodTypeMapping[arg.type]} `);
                }

                if (optionals.includes(arg.name)) {
                  writer.write(">");
                }

                writer.write(";");
                writer.newLine();
              });
            });
            writer.write(">");
          },
          initializer: writer => {
            writer.write(`z.object(`);
            writer.inlineBlock(() => {
              args.forEach(arg => {
                let type = `z.${zodDbMapping[arg.type]}()`;

                if (customZodDbMapping[arg.name]) {
                  type = customZodDbMapping[arg.name];
                }

                writer.write(`${arg.name}: ${type}`);
                writer.conditionalWrite(optionals.includes(arg.name), () => ".nullable()");
                writer.write(",");
                writer.newLine();
              });
            });
            writer.write(")");
          },
        },
      ],
    });

    // For others just export the type
    sourceFile.addTypeAlias({
      isExported: true,
      name: name,
      type: `z.infer < typeof ${name}Schema > `,
    });

    return name;
  }

  methods.forEach(method => {
    const name = toCamelCase(method.name);
    const prefix = name[0].toUpperCase() + name.slice(1);

    // Zod schema for inputs
    let inputName: string | undefined = undefined;
    if (method.args.length > 0) {
      inputName = generateZodType(
        `${prefix}Input`,
        method.args,
        {
          optionals: method.generatorComments.paramOptional,
        },
      );
    }

    let outputName: string | undefined = "void";
    if (method.returns.length > 0) {
      outputName = generateZodType(
        `${prefix}Output`,
        method.returns,
        {
          optionals: method.generatorComments.returnOptional,
        },
      );
    }

    const functionDeclaration = sourceFile.addFunction({
      name,
      isExported: true,
      isAsync: true,
      returnType: `Promise < ${outputName}${method.returnsArray ? "[]" : ""} > `,
      parameters: [
        {
          name: "kwilClient",
          type: "KwilActionClient",
        },
        ...(inputName ? [{
          name: "params",
          type: inputName,
        }] : []),
      ],
    });

    if (method.comments.length > 0) {
      functionDeclaration.addJsDoc(method.comments.join("\n"));
    }

    functionDeclaration.setBodyText(writer => {
      let hasReturn = method.returns.length > 0;
      let returnStatement = hasReturn ? "return" : "";
      let methodCall = hasReturn ? `call < ${outputName}[] > ` : "execute";

      if (method.args.length > 0) {
        writer.writeLine(`const inputs = ${inputName}Schema.parse(params); `);
        writer.writeLine(`${returnStatement} await kwilClient.${methodCall} (`)
        writer.block(() => {
          writer.writeLine(`name: "${method.name}", `);
          writer.writeLine(`inputs, `);
          writer.conditionalWrite(!!method.generatorComments.description, () => `description: "${method.generatorComments.description}", `);
        });
        writer.conditionalWriteLine(method.generatorComments.notAuthorized, () => `, undefined, // Signer is not required here`);
        // Call always returns an array, if it is one item (not a RETURN TABLE) we need to get the first element
        writer.conditionalWrite(hasReturn && !method.returnsArray, () => `).then(result => result[0]`);
        writer.write(");");
      } else {
        writer.write(`${returnStatement} await kwilClient.${methodCall}(`);
        writer.block(() => {
          writer.write(`name: "${method.name}",`);
          writer.write(`inputs: {},`);
          writer.conditionalWrite(!!method.generatorComments.description, () => `description: "${method.generatorComments.description}", `);
        });
        writer.write(")");
        writer.conditionalWrite(hasReturn && !method.returnsArray, () => `.then(result => result[0])`);
        writer.write(";");
      }
    })
  });

  sourceFile.formatText({
    placeOpenBraceOnNewLineForControlBlocks: true,
  })
  sourceFile.saveSync();
}
